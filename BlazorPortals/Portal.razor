@implements IDisposable
@inject PortalRegistration PortalRegistration

@foreach(var fragment in _fragments)
{
    @fragment
}


@code {
    [Parameter, EditorRequired] public string Name { get; set; } = default!;

    private List<RenderFragment> _fragments = new List<RenderFragment>();
    private IDisposable? _subscription;
    private string? _subscribedName;

    public override Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(this);

        if (Name != _subscribedName)
        {
            if (_subscription is not null)
            {
                _subscription.Dispose();
            }

            _fragments = PortalRegistration.GetRenderFragments(Name).ToList();
            _subscription = PortalRegistration.Subscribe(Name, UpdateFragments);
            _subscribedName = Name;

            //this causes 2 renders (only on initial render or when name changes)
            //could refactor this, could implement IComponent instead and manually call render updates
            //see https://github.com/dotnet/aspnetcore/blob/bec278eabea54f63da15e10e654bdfa4168a2479/src/Components/Components/src/Sections/SectionOutlet.cs for example
            StateHasChanged();
        }


        return Task.CompletedTask;
    }


    private void UpdateFragments()
    {
        _fragments = PortalRegistration.GetRenderFragments(Name).ToList();
        StateHasChanged();
    }

    public void Dispose()
    {
        _subscription?.Dispose();
    }
}
